// Each #kernel tells which function to compile; you can have many kernels
#include "..\..\Includes\NoiseFunctions.cginc"
#include "..\..\Includes\ShaderDataGeneratorBasics.cginc"
#pragma kernel GenerateWithTangents
#pragma kernel GenerateWithoutTangents

struct WarpSettings {
	float scale;
	float3 offset1;
	float3 offset2;
	float3 offset3;
};

float3 noiseSettings;
StructuredBuffer<float3> offsets;

float quickNoise(float3 p) {
	return layeredNoise(p, offsets, noiseSettings);
}

RWStructuredBuffer<WarpSettings> warpSettings;
uint numWarps;

[numthreads(32,1,1)]
void GenerateWithTangents(uint3 id : SV_DispatchThreadID) {
	//output: first value is noise value, last 4 are tangent values
	int baseIndex = id.x * 5;
	float3 samplePos = float3(quickNoise(positions[id.x] + warpSettings[0].offset1), quickNoise(positions[id.x] + warpSettings[0].offset2), quickNoise(positions[id.x] + warpSettings[0].offset3));
	for (uint i = 1; i < numWarps; i++) {
		float3 offsetPos = positions[id.x] + samplePos * warpSettings[i - 1].scale;
		samplePos = float3(quickNoise(offsetPos + warpSettings[i].offset1), quickNoise(offsetPos + warpSettings[i].offset2), quickNoise(offsetPos + warpSettings[i].offset3));
	}
	output[baseIndex] = quickNoise(positions[id.x] + samplePos * warpSettings[numWarps - 1].scale);
	float3 tangent = generateTangent(normals[id.x]);
	output[baseIndex + 1] = tangent.x;
	output[baseIndex + 2] = tangent.y;
	output[baseIndex + 3] = tangent.z;
	output[baseIndex + 4] = 1;
}

[numthreads(32, 1, 1)]
void GenerateWithoutTangents(uint3 id : SV_DispatchThreadID) {
	//output: noise value
	int baseIndex = id.x;
	float3 samplePos = float3(quickNoise(positions[id.x] + warpSettings[0].offset1), quickNoise(positions[id.x] + warpSettings[0].offset2), quickNoise(positions[id.x] + warpSettings[0].offset3));
	for (uint i = 1; i < numWarps; i++) {
		float3 offsetPos = positions[id.x] + samplePos * warpSettings[i - 1].scale;
		samplePos = float3(quickNoise(offsetPos + warpSettings[i].offset1), quickNoise(offsetPos + warpSettings[i].offset2), quickNoise(offsetPos + warpSettings[i].offset3));
	}
	output[baseIndex] = quickNoise(positions[id.x] + samplePos * warpSettings[numWarps - 1].scale);
}
