// Each #kernel tells which function to compile; you can have many kernels
#include "..\..\Includes\NoiseFunctions.compute"
#include "..\..\Includes\ShaderDataGeneratorBasics.compute"
#pragma kernel GenerateWithTangents
#pragma kernel GenerateWithoutTangents

struct WarpSettings {
	float scale;
	float3 offset1;
	float3 offset2;
	float3 offset3;
};

RWStructuredBuffer<WarpSettings> warpSettings;
uint numWarps;

[numthreads(32,1,1)]
void GenerateWithTangents(uint3 id : SV_DispatchThreadID) {
	//output: first value is noise value, last 4 are tangent values
	int baseIndex = id.x * 5;
	float3 samplePos = float3(quickNoise(positions[id.x] + warpSettings[0].offset1), quickNoise(positions[id.x] + warpSettings[0].offset2), quickNoise(positions[id.x] + warpSettings[0].offset3));
	for (uint i = 1; i < numWarps; i++) {
		float3 offsetPos = positions[id.x] + samplePos * warpSettings[i - 1].scale;
		samplePos = float3(quickNoise(offsetPos + warpSettings[i].offset1), quickNoise(offsetPos + warpSettings[i].offset2), quickNoise(offsetPos + warpSettings[i].offset3));
	}
	output[baseIndex] = quickNoise(positions[id.x] + samplePos * warpSettings[numWarps - 1].scale);
	float3 t = normalize(cross(normals[id.x], normals[id.x] == float3(0, -1, 0) || normals[id.x] == float3(0, 1, 0) ? float3(0, 0, -1) : float3(0, -1, 0)));
	output[baseIndex + 1] = t.x;
	output[baseIndex + 2] = t.y;
	output[baseIndex + 3] = t.z;
	output[baseIndex + 4] = 1;
}

[numthreads(32, 1, 1)]
void GenerateWithoutTangents(uint3 id : SV_DispatchThreadID) {
	//output: noise value
	int baseIndex = id.x;
	float3 samplePos = float3(quickNoise(positions[id.x] + warpSettings[0].offset1), quickNoise(positions[id.x] + warpSettings[0].offset2), quickNoise(positions[id.x] + warpSettings[0].offset3));
	for (uint i = 1; i < numWarps; i++) {
		float3 offsetPos = positions[id.x] + samplePos * warpSettings[i - 1].scale;
		samplePos = float3(quickNoise(offsetPos + warpSettings[i].offset1), quickNoise(offsetPos + warpSettings[i].offset2), quickNoise(offsetPos + warpSettings[i].offset3));
	}
	output[baseIndex] = quickNoise(positions[id.x] + samplePos * warpSettings[numWarps - 1].scale);
}
